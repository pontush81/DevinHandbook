import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { completeBRFHandbook } from '@/lib/templates/complete-brf-handbook';
import OpenAI from 'openai';

// Initiera Supabase client med service role f√∂r server-side operationer
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// Initiera OpenAI klient
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface AnalysisRequest {
  text: string;
  metadata: {
    title: string;
    totalPages: number;
    language: string;
    documentType: string;
  };
  templateType: 'brf' | 'generic';
}

export async function POST(request: NextRequest) {
  try {
    const { text, metadata, templateType }: AnalysisRequest = await request.json();

    if (!text || !metadata) {
      return NextResponse.json({ error: 'Text och metadata kr√§vs' }, { status: 400 });
    }

    // Kontrollera om texten √§r f√∂r kort eller √§r en fallback-text f√∂r scannade PDF:er
    if (text.trim().length < 100 || 
        text.includes('textextraktion misslyckades') ||
        text.includes('Detta verkar vara en scannad PDF') ||
        text.includes('scannad PDF-fil som inneh√•ller bilder') ||
        metadata.documentType === 'pdf_scanned') {
      
      return NextResponse.json({ 
        error: 'Detta verkar vara en scannad PDF-fil som inneh√•ller bilder ist√§llet f√∂r text. F√∂r att kunna analysera detta dokument beh√∂ver du konvertera det till s√∂kbar text med OCR-programvara.',
        fallback: true,
        scannedPdf: true
      }, { status: 400 });
    }

    if (!process.env.OPENAI_API_KEY) {
      return NextResponse.json({ 
        error: 'OpenAI API-nyckel √§r inte konfigurerad' 
      }, { status: 500 });
    }

    // F√∂rbered mallen f√∂r strukturering
    const templateSections = completeBRFHandbook.sections.map(section => ({
      title: section.title,
      description: section.description,
      keywords: getKeywordsForSection(section.title)
    }));

    // Skapa AI-prompt f√∂r strukturanalys
    const systemPrompt = `Du √§r en expert handboksf√∂rfattare som skapar digitala handb√∂cker. Din uppgift √§r att analysera ett dokument och strukturera det f√∂r att skapa en anv√§ndbar digital handbok.

DITT M√ÖL: Skapa en logisk och anv√§ndbar handboksstruktur baserat p√• dokumentets FAKTISKA inneh√•ll.

ANALYSPROCESS:
1. Identifiera dokumentets typ och syfte
2. Hitta naturliga avdelningar, kapitel, rubriker eller teman
3. Skapa sektioner som √§r anv√§ndbara f√∂r l√§sare av en digital handbok
4. Anv√§nd dokumentets egna rubriker n√§r de finns
5. Gruppera relaterat inneh√•ll logiskt

EXEMPEL P√Ö BRA SEKTIONSINDELNING:

F√∂r stadgar/regler:
- Anv√§nd faktiska paragrafer: "¬ß 1 F√∂reningens namn", "¬ß 2 Medlemskap"

F√∂r instruktioner/manualer:
- F√∂lj stegen: "Installation", "Grundl√§ggande anv√§ndning", "Fels√∂kning"

F√∂r policydokument:
- Anv√§nd policyomr√•den: "S√§kerhetspolicy", "IT-policy", "Personalregler"

F√∂r informationsdokument:
- Gruppera efter √§mne: "Om f√∂retaget", "Kontaktuppgifter", "Tj√§nster"

VIKTIGA PRINCIPER:
- Skapa ALDRIG generiska sektioner som inte motsvarar dokumentets inneh√•ll
- Anv√§nd dokumentets egna rubriker och struktur som grund
- Varje sektion ska vara meningsfull och anv√§ndbar f√∂r handboksl√§sare
- Anpassa antalet sektioner efter dokumentets komplexitet
- F√∂r l√•nga dokument (10+ sidor): Skapa MINST 10-20 sektioner f√∂r b√§ttre navigation
- F√∂r stadgar/regelsamlingar: Skapa en sektion f√∂r varje paragraf eller kapitel
- F√∂r manualer: Dela upp i detaljerade steg och funktioner
- VIKTIGT: Skapa fler, mindre sektioner ist√§llet f√∂r f√•, stora sektioner

Returnera ENDAST ett JSON-objekt enligt f√∂ljande format:
{
  "sections": [
    {
      "title": "Beskrivande titel baserad p√• dokumentets inneh√•ll",
      "content": "Relevant inneh√•ll f√∂r denna sektion",
      "confidence": 0.9,
      "suggestedMapping": "Kort beskrivning av sektionens syfte"
    }
  ]
}

KRITISKA JSON-FORMATERINGSREGLER:
- Anv√§nd ENDAST dubbla citattecken (") f√∂r JSON-str√§ngar
- Escapa alla citattecken i inneh√•llet med \"
- Anv√§nd \\n f√∂r radbrytningar (inte faktiska radbrytningar)
- Inkludera FULLST√ÑNDIGT inneh√•ll f√∂r varje sektion - detta √§r en komplett migration
- Varje sektion ska inneh√•lla ALL relevant text fr√•n originaldokumentet
- VIKTIGT: B√∂rja content-texten direkt med inneh√•llet, ALDRIG med titeln igen!
- Beh√•ll all viktig information, regler, instruktioner och detaljer
- Undvik specialtecken som kan bryta JSON-format

KRITISKA FORMATERINGSREGLER f√∂r content-f√§ltet:

üö´ ABSOLUT F√ñRBJUDET - Upprepa ALDRIG sektionstiteln i content-f√§ltet:
- Om title √§r "¬ß 1 Firma, √§ndam√•l och s√§te" - b√∂rja INTE content med "¬ß 1" eller "Firma, √§ndam√•l och s√§te"
- Om title √§r "Stadgar" - b√∂rja INTE content med "Stadgar" eller "Dessa stadgar"
- Om title √§r "Kontaktuppgifter" - b√∂rja INTE content med "Kontaktuppgifter"
- Titeln visas redan separat som rubrik - b√∂rja direkt med inneh√•llet!

‚úÖ KORREKT FORMATERING:
- Anv√§nd dubbla radbrytningar (\\n\\n) mellan stycken f√∂r b√§ttre l√§sbarhet
- Skapa punktlistor med "‚Ä¢ " f√∂r viktiga punkter
- Anv√§nd "**text**" f√∂r fetstil p√• viktiga begrepp
- Strukturera inneh√•llet med tydliga stycken ist√§llet f√∂r en l√•ng textklump
- L√§gg till radbrytningar efter rubriker och f√∂re listor
- G√∂r texten l√§sbar och v√§lstrukturerad

EXEMPEL P√Ö KORREKT ANV√ÑNDNING:

‚úÖ R√ÑTT (fullst√§ndigt inneh√•ll utan titelupprepning):
Title: "¬ß 1 Firma, √§ndam√•l och s√§te"
Content: "F√∂reningens firma √§r Riksbyggen Bostadsr√§ttsf√∂rening Segerstaden. F√∂reningen har till √§ndam√•l att fr√§mja medlemmarnas ekonomiska intressen genom att i f√∂reningens hus, mot ers√§ttning, till f√∂reningens medlemmar uppl√•ta bostadsl√§genheter f√∂r permanent boende, och i f√∂rekommande fall lokaler, till nyttjande utan begr√§nsning i tiden. F√∂reningen ska i sin verksamhet fr√§mja de kooperativa principerna s√•som de kommer till uttryck i dessa stadgar och verka f√∂r en socialt, ekonomiskt och milj√∂m√§ssigt h√•llbar utveckling. F√∂reningens styrelse ska ha sitt s√§te i V√§xj√∂ kommun."

‚úÖ R√ÑTT (komplett sektion):
Title: "Styrelse och f√∂rvaltning"
Content: "Styrelsen best√•r av minst tre och h√∂gst sju ledam√∂ter som v√§ljs av f√∂reningsst√§mman f√∂r en mandatperiod om ett √•r. Ordf√∂randen leder styrelsens arbete och representerar f√∂reningen ut√•t. Sekreteraren ansvarar f√∂r protokollf√∂ring och korrespondens. Styrelsen sammantr√§der minst fyra g√•nger per √•r och √§r beslutsf√∂r n√§r minst h√§lften av ledam√∂terna √§r n√§rvarande."

üö´ FEL (upprepar titeln):
Title: "¬ß 1 Firma, √§ndam√•l och s√§te"
Content: "¬ß 1 Firma, √§ndam√•l och s√§te - F√∂reningen fr√§mjar..."

VIKTIGA REGLER:
- Skapa EN sektion f√∂r varje huvudavsnitt/kapitel i dokumentet
- Anv√§nd de FAKTISKA rubrikerna fr√•n dokumentet som sektionstitlar
- Om dokumentet har 15 kapitel, skapa 15 sektioner
- Om dokumentet har 3 huvuddelar, skapa 3 sektioner
- F√∂r L√ÖNGA dokument (20+ sidor): Dela upp stora kapitel i mindre delsektioner
- Varje sektion ska ha minst 50 tecken inneh√•ll (kortare sektioner √§r OK f√∂r b√§ttre navigation)
- Confidence ska vara mellan 0.1-1.0 baserat p√• hur tydlig strukturen √§r
- VIKTIGT: Formatera inneh√•llet f√∂r maximal l√§sbarhet med stycken, listor och struktur
- Ta bort redundanta upprepningar av sektionstitlar i inneh√•llet - titeln visas redan separat
- M√ÖL: Skapa s√• m√•nga relevanta sektioner som m√∂jligt f√∂r b√§ttre anv√§ndbarhet`;

    const userPrompt = `Som handboksf√∂rfattare ska du analysera detta dokument och skapa en anv√§ndbar struktur f√∂r en digital handbok.

DOKUMENTINFORMATION:
- Titel: ${metadata.title}
- Typ: ${metadata.documentType}
- Spr√•k: ${metadata.language}
${metadata.totalPages ? `- Antal sidor: ${metadata.totalPages}` : ''}

UPPGIFT:
Analysera dokumentet nedan och skapa sektioner som √§r logiska och anv√§ndbara f√∂r l√§sare av en digital handbok. Fokusera p√• dokumentets faktiska inneh√•ll och struktur.

${metadata.totalPages && metadata.totalPages > 15 ? 
`üéØ SPECIELLA INSTRUKTIONER F√ñR L√ÖNGT DOKUMENT (${metadata.totalPages} sidor):
- Detta √§r ett omfattande dokument som kr√§ver strukturering
- Skapa EXAKT 12-15 v√§ldefinierade sektioner (max 15 f√∂r att undvika JSON-trunkering)
- FULLST√ÑNDIGT inneh√•ll per sektion - inkludera all relevant text fr√•n originalet
- Fokusera p√• de viktigaste kapitlen och paragraferna
- Prioritera kvalitet √∂ver kvantitet - v√§lj de mest relevanta sektionerna
- VIKTIGT: Korta sammanfattningar, inga l√•nga texter!` : 
''}

DOKUMENT ATT ANALYSERA:
${text}`;

    try {
      const completion = await openai.chat.completions.create({
        model: "gpt-4o-mini", // Tillbaka till billigare modell med optimerad prompt
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ],
        temperature: 0.1,
        max_tokens: metadata.totalPages && metadata.totalPages > 15 ? 12000 : 8000, // H√∂gre gr√§nser f√∂r fullst√§ndigt inneh√•ll
        response_format: { type: "json_object" }
      });

      const responseContent = completion.choices[0]?.message?.content;
      if (!responseContent) {
        return NextResponse.json({ 
          error: 'Ingen respons fr√•n AI-analysen' 
        }, { status: 500 });
      }

      let analysisResult;
      try {
        analysisResult = JSON.parse(responseContent);
      } catch (parseError) {
        console.error('Fel vid parsning av AI-respons:', parseError);
        console.error('Problematisk AI-respons (f√∂rsta 1000 tecken):', responseContent.substring(0, 1000));
        console.error('Problematisk AI-respons (sista 1000 tecken):', responseContent.substring(Math.max(0, responseContent.length - 1000)));
        
        // F√∂rs√∂k att reparera JSON genom att ta bort oavslutade str√§ngar
        try {
          // Hitta sista giltiga JSON-struktur
          let repairedJson = responseContent;
          
          // Ta bort eventuell text efter sista }
          const lastBraceIndex = repairedJson.lastIndexOf('}');
          if (lastBraceIndex > 0) {
            repairedJson = repairedJson.substring(0, lastBraceIndex + 1);
          }
          
          // Om det fortfarande inte fungerar, f√∂rs√∂k att hitta sista kompletta sektion
          if (!repairedJson.includes('"sections"')) {
            throw new Error('Ingen sections-nyckel hittades');
          }
          
          // F√∂rs√∂k att bygga om JSON med bara kompletta sektioner
          try {
            analysisResult = JSON.parse(repairedJson);
            console.log('‚úÖ Lyckades reparera JSON');
          } catch (secondError) {
            // Sista f√∂rs√∂k: Hitta alla kompletta sektioner manuellt
            console.log('üîß F√∂rs√∂ker manuell JSON-reparation...');
            
            // Ny strategi: Leta efter individuella sektioner direkt i texten
            const sections = [];
            
            // Regex f√∂r att hitta sektioner - mycket mer flexibel
            const sectionPattern = /\{\s*"title":\s*"([^"]+)"\s*,\s*"content":\s*"([^"]+)"\s*,\s*"confidence":\s*([\d.]+)\s*(?:,\s*"suggestedMapping":\s*"([^"]*)")?\s*\}/g;
            
            let match;
            while ((match = sectionPattern.exec(responseContent)) !== null) {
              const [, title, content, confidence, suggestedMapping] = match;
              
              if (title && content && confidence) {
                sections.push({
                  title: title.trim(),
                  content: content.trim(),
                  confidence: parseFloat(confidence),
                  suggestedMapping: suggestedMapping || title.trim()
                });
              }
            }
            
            // Om regex inte fungerade, f√∂rs√∂k en enklare approach
            if (sections.length === 0) {
              console.log('üîß F√∂rs√∂ker alternativ extraction...');
              
              // Leta efter "title": f√∂ljt av "content": f√∂ljt av "confidence":
              const titleMatches = responseContent.match(/"title":\s*"([^"]+)"/g);
              const contentMatches = responseContent.match(/"content":\s*"([^"]+)"/g);
              const confidenceMatches = responseContent.match(/"confidence":\s*([\d.]+)/g);
              
              if (titleMatches && contentMatches && confidenceMatches) {
                const minLength = Math.min(titleMatches.length, contentMatches.length, confidenceMatches.length);
                
                for (let i = 0; i < minLength; i++) {
                  const title = titleMatches[i].match(/"title":\s*"([^"]+)"/)?.[1];
                  const content = contentMatches[i].match(/"content":\s*"([^"]+)"/)?.[1];
                  const confidence = confidenceMatches[i].match(/"confidence":\s*([\d.]+)/)?.[1];
                  
                  if (title && content && confidence) {
                    sections.push({
                      title: title.trim(),
                      content: content.trim(),
                      confidence: parseFloat(confidence),
                      suggestedMapping: title.trim()
                    });
                  }
                }
              }
            }
            
            if (sections.length > 0) {
              analysisResult = { sections };
              console.log(`‚úÖ Lyckades extrahera ${sections.length} sektioner manuellt`);
            } else {
              throw new Error('Inga giltiga sektioner kunde extraheras fr√•n den trunkerade responsen');
            }
          }
        } catch (repairError) {
          console.error('‚ùå Kunde inte reparera JSON:', repairError);
          return NextResponse.json({ 
            error: 'Kunde inte tolka AI-responsen' 
          }, { status: 500 });
        }
      }

      // Validera och f√∂rb√§ttra resultatet
      if (!analysisResult.sections || !Array.isArray(analysisResult.sections)) {
        return NextResponse.json({ 
          error: 'Ogiltigt analysresultat fr√•n AI' 
        }, { status: 500 });
      }

      // Filtrera och validera sektioner
      const validSections = analysisResult.sections
        .filter((section: any) => 
          section.title && 
          section.content && 
          section.content.trim().length >= 100 // Kr√§v mer substantiellt inneh√•ll f√∂r fullst√§ndig migration
        )
        .map((section: any, index: number) => {
          let cleanContent = section.content.trim();
          const title = section.title.trim();
          
          // Ta bort titelupprepningar fr√•n b√∂rjan av content
          // Hantera olika varianter av titelupprepning
          const titleVariants = [
            title, // Exakt titel
            title.replace(/^¬ß\s*\d+\s*/, ''), // Titel utan paragrafnummer
            title.replace(/^¬ß\s*\d+\s*/, '').replace(/^\w+,?\s*/, ''), // Bara slutdelen av titeln
          ];
          
          for (const variant of titleVariants) {
            if (variant && cleanContent.toLowerCase().startsWith(variant.toLowerCase())) {
              cleanContent = cleanContent.substring(variant.length).trim();
              // Ta bort eventuella inledande bindestreck, kolon eller punkter
              cleanContent = cleanContent.replace(/^[-:.\s]+/, '').trim();
              break;
            }
          }
          
          // Extra s√§kerhet: ta bort paragrafnummer fr√•n b√∂rjan om det finns kvar
          cleanContent = cleanContent.replace(/^¬ß\s*\d+\s*[^\w]*/, '').trim();
          
          return {
            title: title,
            content: cleanContent,
            confidence: Math.max(0.1, Math.min(1.0, section.confidence || 0.7)),
            suggestedMapping: section.suggestedMapping || section.title,
            order: index + 1
          };
        });

      if (validSections.length === 0) {
        return NextResponse.json({ 
          error: 'Inga giltiga sektioner kunde identifieras' 
        }, { status: 400 });
      }

      // Spara analysen i databasen
      const { data: analysisData, error: analysisError } = await supabase
        .from('document_analyses')
        .insert({
          original_text: text.substring(0, 10000), // Begr√§nsa storlek
          metadata: {
            ...metadata,
            analysis_time: new Date().toISOString(),
            model: "gpt-4o-mini",
            prompt_version: "2.5"
          },
          analysis_result: {
            sections: validSections,
            summary: {
              total_sections: validSections.length,
              avg_confidence: validSections.reduce((sum: number, s: any) => sum + s.confidence, 0) / validSections.length,
              template_type: templateType
            }
          },
          template_type: templateType
        })
        .select()
        .single();

      if (analysisError) {
        console.error('Fel vid sparning av analys:', analysisError);
        // Forts√§tt √§nd√• och returnera resultatet
      }

      return NextResponse.json({
        success: true,
        sections: validSections,
        summary: {
          total_sections: validSections.length,
          avg_confidence: validSections.reduce((sum: number, s: any) => sum + s.confidence, 0) / validSections.length,
          template_type: templateType
        },
        analysis_id: analysisData?.id
      });

    } catch (openaiError) {
      console.error('Fel vid AI-analys:', openaiError);
      return NextResponse.json({ 
        error: 'Kunde inte genomf√∂ra AI-analys' 
      }, { status: 500 });
    }

  } catch (error) {
    console.error('Ov√§ntat fel vid strukturanalys:', error);
    return NextResponse.json({ 
      error: 'Ett ov√§ntat fel intr√§ffade' 
    }, { status: 500 });
  }
}

// Hj√§lpfunktion f√∂r att f√• nyckelord f√∂r olika sektioner
function getKeywordsForSection(sectionTitle: string): string[] {
  const keywordMap: { [key: string]: string[] } = {
    'V√§lkommen till din BRF': ['v√§lkommen', 'introduktion', 'presentation', 'bostadsr√§ttsf√∂rening'],
    'Om f√∂reningen': ['styrelse', 'organisation', 'historia', 'bildad', 'medlemmar'],
    'Ekonomi och avgifter': ['m√•nadsavgift', 'ekonomi', 'budget', 'kostnad', 'avgift'],
    'Regler och ordningsregler': ['regler', 'ordning', 'f√∂rbjudet', 'till√•tet', 'policy'],
    'Fastigheten och teknik': ['fastighet', 'teknisk', 'installation', 'system', 'underh√•ll'],
    'Renovering och underh√•ll': ['renovering', 'underh√•ll', 'reparation', 'upprustning', 'f√∂rb√§ttring'],
    'Hemf√∂rs√§kring och f√∂rs√§kringar': ['f√∂rs√§kring', 'hemf√∂rs√§kring', 'skada', 'ansvar'],
    'Uthyrning och andrahandsuthyrning': ['uthyrning', 'andrahand', 'hyra', 'kontrakt'],
    'F√∂rs√§ljning av bostadsr√§tt': ['f√∂rs√§ljning', 'k√∂p', '√∂verl√•telse', 'pantbrev'],
    'Parkeringsplatser': ['parkering', 'garage', 'bilplats', 'parkering'],
    'Gemensamma utrymmen': ['gemensamma', 'utrymmen', 'tv√§ttstuga', 'f√∂rr√•d'],
    'Sophantering och √•tervinning': ['sopor', '√•tervinning', 'avfall', 'kompost'],
    'Trygghet och s√§kerhet': ['trygghet', 's√§kerhet', 'larm', 'brand', 'n√∂dsituation'],
    'Kontaktuppgifter': ['kontakt', 'telefon', 'e-post', 'adress', 'styrelse']
  };

  return keywordMap[sectionTitle] || [];
} 