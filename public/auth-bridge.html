<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Auth Bridge - Handbok.org</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      color: #444;
      background-color: #f9f9f9;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
      font-size: 24px;
      margin-top: 0;
    }
    p {
      line-height: 1.5;
    }
    .status {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
    }
    .active {
      background-color: #e6f7ee;
      color: #0d854f;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Auth Bridge</h1>
    <p>Status: <span class="status active">Aktiv</span></p>
    <p>Denna sida hjälper till att hantera autentisering mellan subdomäner på handbok.org.</p>
    <p>Sidan används internt av systemet och behöver vara öppen för att dela inloggningsinformation.</p>
    <p>Teknisk status: <span id="auth-status">Initializing...</span></p>
  </div>

  <script>
    /**
     * Auth Bridge Script
     * 
     * This script allows authenticated sessions to be shared across subdomains
     * by securely storing authentication tokens on the main domain and
     * communicating with subdomains via postMessage.
     */
    (function() {
      console.log('[Auth Bridge] Initializing...');
      const statusElement = document.getElementById('auth-status');
      const AUTH_KEYS = [
        'supabase.auth.token',
        'supabase.auth.refresh_token',
        'supabase.auth.expires_at',
        'supabase-auth-token',
        'user_session',
        'user_metadata'
      ];
      
      // This flag helps the parent page know if we're ready
      let isReady = false;
      
      // Helper to broadcast auth status to all frames
      function broadcastAuthStatus() {
        try {
          const authTokenKey = 'supabase.auth.token';
          const hasAuth = !!localStorage.getItem(authTokenKey);
          
          // Notify parent and any message origins of auth status
          window.parent.postMessage({
            type: 'auth_status',
            isAuthenticated: hasAuth
          }, '*');
          
          statusElement.textContent = hasAuth ? 'Authenticated' : 'Not authenticated';
          statusElement.style.color = hasAuth ? '#0d854f' : '#888';
        } catch (e) {
          console.error('[Auth Bridge] Error broadcasting auth status:', e);
          statusElement.textContent = 'Error: ' + e.message;
          statusElement.style.color = '#dc3545';
        }
      }
      
      // Listen for messages from other windows/frames
      window.addEventListener('message', function(event) {
        // Only accept messages from our own domains
        if (!event.origin.match(/^https?:\/\/(.*\.)?handbok\.org$/)) {
          console.warn('[Auth Bridge] Rejected message from unauthorized origin:', event.origin);
          return;
        }
        
        const data = event.data;
        
        // Skip if not an object or missing required info
        if (!data || typeof data !== 'object') return;
        
        try {
          // Handle different message types
          switch(data.type) {
            case 'auth_ping':
              // Respond to ping, let the other window know we're alive
              event.source.postMessage({
                type: 'auth_pong',
                isReady: isReady
              }, event.origin);
              break;
              
            case 'auth_get':
              // Retrieve auth data for a specific key
              if (AUTH_KEYS.includes(data.key)) {
                const value = localStorage.getItem(data.key);
                event.source.postMessage({
                  type: 'auth_data',
                  key: data.key,
                  value: value,
                  request_id: data.request_id
                }, event.origin);
              }
              break;
              
            case 'auth_set':
              // Store auth data for a specific key
              if (AUTH_KEYS.includes(data.key)) {
                if (data.value === null) {
                  localStorage.removeItem(data.key);
                } else {
                  localStorage.setItem(data.key, data.value);
                }
                
                // Broadcast the updated auth status
                broadcastAuthStatus();
                
                // Confirm action
                event.source.postMessage({
                  type: 'auth_set_done',
                  key: data.key,
                  request_id: data.request_id
                }, event.origin);
              }
              break;
              
            case 'auth_clear':
              // Clear all auth data
              AUTH_KEYS.forEach(key => {
                localStorage.removeItem(key);
              });
              
              broadcastAuthStatus();
              
              // Confirm action
              event.source.postMessage({
                type: 'auth_clear_done',
                request_id: data.request_id
              }, event.origin);
              break;
          }
        } catch (e) {
          console.error('[Auth Bridge] Error processing message:', e);
          // Let the sender know about the error
          event.source.postMessage({
            type: 'auth_error',
            error: e.message,
            request_id: data.request_id
          }, event.origin);
        }
      });
      
      // Initialize
      try {
        broadcastAuthStatus();
        isReady = true;
        console.log('[Auth Bridge] Ready');
        statusElement.textContent = 'Ready';
      } catch (e) {
        console.error('[Auth Bridge] Initialization error:', e);
        statusElement.textContent = 'Error: ' + e.message;
        statusElement.style.color = '#dc3545';
      }
      
      // Keep checking auth status periodically
      setInterval(broadcastAuthStatus, 10000);
    })();
  </script>
</body>
</html> 